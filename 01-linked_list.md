# 链表技巧

- 双指针：快慢指针，解决相交、倒数N位数、中位数、环
- 虚拟头结点
- 优先级队列：前K位数
- 分治思想：拆分链表、合并链表
    - 关键在于怎么表达每个子链表

## 1.合并

### 合并两个有序链表（21）

1. 增加新的链表（带虚拟节点）
2. 两个指针指向两个链表，将最小值加到新的链表中

### 合并 K 个有序链表（23）

方案一：使用递归+分治
1. 每次递归，将数组对半分成两个数组，各自递归合并
2. 将分开的两个数组合并后的两个链表，合并成一个链表

方案二：使用二叉堆排序
1. 将每个链表加入到二叉堆
2. 每次从二叉堆拿出一个节点，并将节点的next重新加入二叉堆
3. 直到二叉堆为空

### 丑数2（264）

丑数是质因数只包含2、3、5的正整数
可以拆分为 3 个链表，变成比较后合并成一个新链表
链表1：2的倍数的节点，取链表前面元素的2倍作为新的值
链表2：3的倍数的节点...
链表3：5的倍数的节点...

### 有序矩阵中第K小的元素（378）

将矩阵每一行数组视为一个链表，转成合并链表问题
1. 将每一行第一个元素和所在行和列，加入优先级队列
2. 每次从优先级队列取出一个数，将这个数对应行下一个数加入优先级队列
3. 以此类推，直到拿到第K个数返回

### 查找和最小的K对数组（373）

将第一个数组和第二个数组的一个元素的对认为是一个链表，转成合并链表问题
1. 将第一个数组所有元素跟第二个数组第一个元组组成数组，加入优先级队列
2. 每次从优先级队列取出一个数，将数和第二个数组下一个值组对加入优先级队列
3. 以此类推，直到拿到第K个数返回

### 两数相加（2）

视为两个链表合并问题
1. 同时遍历两个数组元素，相加除以10，将个位数记录到新链表，并暂存十位数
2. 将下两个数相加并加上十位数，得出新的个位数和十位数
3. 以此类推，直到两个链表都结束or，最后如果十位数大于0，再额外添加一个数

### 两数相加2（445）

先翻转链表再合并


## 2.分解
### 链表的分解（86）

将小于 x 的节点挪到链表左侧，其他保留在链表右侧

1. 新增两个链表
2. 遍历链表，将小于x的节点加到新链表1，将其他节点加到新链表2
3. 将链表1的尾节点指向链表2的头结点

### 删除排序链表中的重复元素2（82）

分解链表的方式
1. 链表1记录不重复的元素，链表2记录重复的元素
2. 如果当前节点跟其next节点值一样，或者跟链表2节点值一样，则加入链表2
3. 否则加入链表1

## 3.快慢指针


### 寻找单链表的倒数第 K 个节点（19）

1. 快慢节点，快节点先前进 K 个节点
2. 接着，快慢指针一直前进，直到快指针到达终点
3. 此时慢指针就是倒数第 K 个节点（前进了 N - K 个节点)

### 寻找单链表的中点（876）

1. 快慢节点，快节点按照 2 步前进，慢节点按照 1 步前进
2. 直到快节点到达终点，慢节点就是中点

### 判断单链表是否包含环并找出环起点（142）

1. 快慢指针，快节点按照 2 步前进，慢节点按照 1 步前进
2. 如果快节点跟慢节点相等，则有环
    - 假设慢节点前进了 K 步，则快节点前进了 2K 步
    - 另外快节点比慢节点多走了一环，则一环就是 K 步
    - 环起点离相遇点距离 M，则离头节点为 K - M
3. 慢节点指向头节点，快慢节点按照 1 步前进，直到相遇，即环起点

### 判断两个单链表是否相交并找出交点（160）

方案一：退化为环，找出换节点
1. 将链表1的尾节点指向其头节点
2. 快慢指针找到链表2的环节点，即相交点

方案二：两个指针，各自遍历两个链表，遍历完则开始遍历另一个链表，直到相遇
1. 指针一遍历链表1，指针二遍历链表2
2. 如果遍历完一个链表则开始遍历另一个链表
3. 如果两个指针节点相等，则是相交点，或者到了尾部（长度一样返回None）


## 4.反转链表

### 整个链表反转（206）

方案一：迭代
1. 定义变量，`pre, cur, nxt = None, head, head.next`
    - pre 表示当前遍历节点的前一个节点
    - cur 表示当前遍历节点
    - nxt 表示当前遍历节点的后一个节点
2. 遍历 cur，直到为 None，将 cur 的 next 指向 pre
3. 最后 pre 表示最后一个节点，即新的头部节点，返回

```python
def reverse(head: ListNode) -> ListNode:
    if not head or not head.next:
        return

    pre, cur, nxt = None, head, head.next
    while cur:
        cur.next = pre
        pre = cur
        cur = nxt
        if nxt.next:
            nxt = nxt.next
    return pre
```

方案二：递归
1. 假设除head外，head.next之后的节点都进行了翻转
    - head还指向 head.next
2. 将head.next 和 head的指针反转
    - 将 head.next 的 next指向head
    - head.next 指向 None
3. 返回 head.next 翻转后的新头节点

```python
def reverse(head: ListNode) -> ListNode:
    if not head or not head.next:
        return head

    new_head = reverse(head.next)
    head.next.next = head
    head.next = None
    return new_head
```


### 反转前K个节点

跟反转整个链表类似
区别在于
- 结束时机，遍历到第 k 节点结束
- 需要将 head 指向第 k+1 节点，而不是 None

方案一：迭代
1. 维护 pre, cur, nxt 节点
2. 逐个反转，直到 k == 0， 此时 cur 是 k+1 节点
3. 将head的next 指向 cur
3. 返回 pre 节点作为新的头部节点

方案二：递归

### 反转部分节点（92）

找到第m个节点后，退化为反转前 k 个节点，k=n-m+1

### K 个一组反转链表（25）

1. 每次遍历 k 个节点，找到下一个k组的头节点
2. 反转当前k个节点
3. 将当前k个节点原本的head next指向下一个k组头节点
4. 将下个k组头节点作为新组头节点，直到结束