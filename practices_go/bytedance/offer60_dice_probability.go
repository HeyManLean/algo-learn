package bytedance

import "math"

func statisticsProbability(n int) []float64 {
	/*
		剑指 Offer 60. n个骰子的点数

		把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。

		你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。


		输入: 1
		输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]
		解释: 1个骰子可能的点数为1-6，每个点数概率相同，均为 1/6 ≈ 0.16667

		输入: 2
		输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]
		解释: 2个骰子点数和范围为2-12，概率分别为：
		     和为2: 1/36, 和为3: 2/36, 和为4: 3/36, 和为5: 4/36, 和为6: 5/36, 和为7: 6/36,
		     和为8: 5/36, 和为9: 4/36, 和为10: 3/36, 和为11: 2/36, 和为12: 1/36

		1 <= n <= 11
	*/
	// 如n=2, 和为3的组合有 1+2 和 2+1, 和为4的组合有1+3、2+2、3+1
	// 值范围是 n~n*6, 总数是 5n+1，组合数是 6 的 n次方
	// dp[i][j] 表示 i 个骰子，和为 j 的数量
	// dp[i][j] 假设第i个骰子投的是1,2...6, 那么 dp[i][j] = sum(dp[i-1][j-k] for k in 1..6)
	// 可以降维，只依赖上一行，每行逆向生成

	// 值范围是 n-6n, 个数是 5n+1
	dp := make([]int, 6*n+1)

	// 第一行，骰子数为1
	for i := 1; i <= 6; i++ {
		dp[i] = 1
	}

	for i := 2; i <= n; i++ {
		// 值范围 n~n*i

		// 骰子数增多，前面的数应该置为0，不属于值范围的数应该为0
		newDp := make([]int, 6*n+1)
		for j := 6 * i; j >= i; j-- {
			for k := 1; k <= 6 && k <= j; k++ {
				newDp[j] += dp[j-k]
			}
		}
		dp = newDp

	}
	res := make([]float64, 5*n+1)
	total := math.Pow(6, float64(n))
	for i, cnt := range dp[n : 6*n+1] {
		res[i] = float64(cnt) / total
	}

	return res
}
