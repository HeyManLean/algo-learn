package bytedance

func solveSudoku(board [][]byte) {
	/*
		37. 解数独

		编写一个程序，通过填充空格来解决数独问题。

		数独的解法需 遵循如下规则：
		1. 数字 1-9 在每一行只能出现一次。
		2. 数字 1-9 在每一列只能出现一次。
		3. 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）

		数独部分空格内已填入了数字，空白格用 '.' 表示。

		示例 1：
		输入：board =
		[["5","3",".",".","7",".",".",".","."],
		 ["6",".",".","1","9","5",".",".","."],
		 [".","9","8",".",".",".",".","6","."],
		 ["8",".",".",".","6",".",".",".","3"],
		 ["4",".",".","8",".","3",".",".","1"],
		 ["7",".",".",".","2",".",".",".","6"],
		 [".","6",".",".",".",".","2","8","."],
		 [".",".",".","4","1","9",".",".","5"],
		 [".",".",".",".","8",".",".","7","9"]]
		输出：
		[["5","3","4","6","7","8","9","1","2"],
		 ["6","7","2","1","9","5","3","4","8"],
		 ["1","9","8","3","4","2","5","6","7"],
		 ["8","5","9","7","6","1","4","2","3"],
		 ["4","2","6","8","5","3","7","9","1"],
		 ["7","1","3","9","2","4","8","5","6"],
		 ["9","6","1","5","3","7","2","8","4"],
		 ["2","8","7","4","1","9","6","3","5"],
		 ["3","4","5","2","8","6","1","7","9"]]
		解释：输入的数独如上图所示，唯一有效的解决方案如下所示：

		board.length == 9
		board[i].length == 9
		board[i][j] 是一位数字或者 '.'
		题目数据 保证 输入数独仅有一个解
	*/
	// 暴力+回溯
	// for 1-9 找到不在行、列、九宫格内的数字列表，如果为空，则返回
	//    先填入，然后回溯下一个格子，直到最后一个格子
	//    如果没找到结果，则填入下一个数字
	//    如果没有数字，则清空，返回
	CHARS := []byte("123456789")
	m, n := len(board), len(board[0])

	var dfs func(pos int) bool
	dfs = func(pos int) bool {
		if pos >= m*n {
			return true
		}
		i, j := pos/n, pos%n
		if board[i][j] != '.' {
			return dfs(pos + 1)
		}

		// 当前行
		exists := make(map[byte]bool)
		for x := 0; x < m; x++ {
			if board[x][j] != '.' {
				exists[board[x][j]] = true
			}
		}
		// 当前列
		for y := 0; y < n; y++ {
			if board[i][y] != '.' {
				exists[board[i][y]] = true
			}
		}
		// 当前九宫格
		// 九宫格开始行 = i / 3 * 3, j/3*3
		for x := i / 3 * 3; x < i/3*3+3; x++ {
			for y := j / 3 * 3; y < j/3*3+3; y++ {
				if board[x][y] != '.' {
					exists[board[x][y]] = true
				}
			}
		}

		for _, c := range CHARS {
			if exists[c] {
				continue
			}
			board[i][j] = c
			if dfs(pos + 1) {
				return true
			}
			board[i][j] = '.'
		}

		return false
	}
	dfs(0)
}
